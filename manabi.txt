-(-A//B) # 切り上げ

itertoolsが効率的な計算するライブラリ、順列や組み合わせなど

明らかに2の倍数を2で割り算してWAでも/を//にしたら通るかも？

pythonは再帰が速い　それ以外原因ならpypyが速いかも

二次元リストをソートしたら各小リストの0番目要素でソートされる

便利な手法のPythonなど。https://qiita.com/chun1182/items/ddf2b6cba932b2bb0d4e
	実質スニペ
	動的計画、しゃくとり、列挙、素因数分解、メモか、UnionFind、DFS探索など


＜アルゴリズム＞

gcd 最大公約数
	
imos法：範囲に足して最大値を求めるなど		とあるアルゴリズム解説
						https://hackmd.io/@AymkShhZRFeX98HUU2MuHQ/Hk3hLVlWz?type=view

バケツソートしてくれるSortedSet			https://github.com/tatyam-prime/SortedSet/blob/main/SortedSet.py

累積和： a1,a2...を0,a1,a1+a2...として記録

二部探索(bisect)：　ソートされた配列に対して、探す値が大きいか小さいかで探索　だいたい真ん中から初めて再帰

bit全探索(bit_search)：	少ないメモリで固定長の2値の文を全探索 (と)の順番など？

ダイクストラ法：　始状態からいけるとこのうち最小コストのものを一つずつ決定する(頂点数-1だけ繰り返す)
	グラフの表現：	隣接行列：　　n*n行列のうち0と1で辺があるか表す。自分に向いたやつないなら対角成分0。
			隣接リスト：　不定長nリストを含むリスト、i番目のリストの要素は頂点iが隣接する点の番号。
			有向なら片方だけに入れて、重み付きなら10進数を使うか3次元行列(各要素が[番号、重み])

ﾜｰシャルフロイド法(Warshall_Floyd)：　すべての組み合わせで最短経路(重み付隣接行列を使う、繋がってないのはINFとする)
					重み付最短経路

DFS,BFS 幅深さ

UnionFind ユニ木：　同じグループかどうかを判定するための木、まとめる(二頂点間に辺を張る)のはできるが分割無理、距離も無理

メモ化再帰：　再帰関数でf(5),f(4),...と求めるとf(3)が何回も計算される！→メモリを犠牲にして辞書に各結果を記録しちゃう

DP：	n個のうち重さの総和がWを越えない時の価値の総和の最大値、など	https://qiita.com/drken/items/a5e6fe22863b7992efdb
	漸化式：	dp[i+1][w] = max(dp[i][w-weight[i]] + value[i], dp[i][w]) 	dp[i+1]：i番目までの品物のなかから重さW以下で選んだ時の価値の総和の最大値
	i個めまでの状態での解と、選んだもののインデックスがあれば、i+1個めまでの状態での解もわかる

	選択した数の合計のDP：二次元配列にして、深さi時点で合計jにできるよという配列をboolでつくる
	するとN枚目時点で合計Sにできるかできないかという結果がでる
	できることが分かるなら、逆順に、N-aとN-bで存在する方を辿っていけばいい

	

heapqライブラリ
heapq.heapifyリストを優先度付キューに変換、heapq.heappop最小値を取り出すheapq.heappush挿入


メモ化再帰　再帰がめちゃくちゃあって、かつ状態数がそこそこ有限のときに呪文を入れるだけで通る
from functools import lru_cache
@lru_cache
def f(n):
    if n == 0:
        return 1
    return f(n // 2) + f(n // 3)
print(f(int(input())))




調べたい
modint
BIT
最大流、最小費用流

使えるようになりたい
Segment Tree
グラフのもんだい　